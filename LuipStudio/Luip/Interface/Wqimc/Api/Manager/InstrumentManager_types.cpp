/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "InstrumentManager_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Interface { namespace Wqimc { namespace Api { namespace Manager {

int _kMeasureModeValues[] = {
  MeasureMode::Online,
  MeasureMode::Offine
};
const char* _kMeasureModeNames[] = {
  "Online",
  "Offine"
};
const std::map<int, const char*> _MeasureMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMeasureModeValues, _kMeasureModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataTypeValues[] = {
  DataType::Bool,
  DataType::Option,
  DataType::Int,
  DataType::Float,
  DataType::String,
  DataType::IntArray,
  DataType::Byte,
  DataType::Short,
  DataType::Long,
  DataType::Double
};
const char* _kDataTypeNames[] = {
  "Bool",
  "Option",
  "Int",
  "Float",
  "String",
  "IntArray",
  "Byte",
  "Short",
  "Long",
  "Double"
};
const std::map<int, const char*> _DataType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kDataTypeValues, _kDataTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRoleTypeValues[] = {
  RoleType::Guest,
  RoleType::Administrator,
  RoleType::Engineer,
  RoleType::Super
};
const char* _kRoleTypeNames[] = {
  "Guest",
  "Administrator",
  "Engineer",
  "Super"
};
const std::map<int, const char*> _RoleType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRoleTypeValues, _kRoleTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Authorization::~Authorization() throw() {
}


void Authorization::__set_name(const std::string& val) {
  this->name = val;
}

void Authorization::__set_expirationDate(const int64_t val) {
  this->expirationDate = val;
}

uint32_t Authorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expirationDate);
          this->__isset.expirationDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Authorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Authorization");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expirationDate", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->expirationDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Authorization &a, Authorization &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.expirationDate, b.expirationDate);
  swap(a.__isset, b.__isset);
}

Authorization::Authorization(const Authorization& other0) {
  name = other0.name;
  expirationDate = other0.expirationDate;
  __isset = other0.__isset;
}
Authorization& Authorization::operator=(const Authorization& other1) {
  name = other1.name;
  expirationDate = other1.expirationDate;
  __isset = other1.__isset;
  return *this;
}
void Authorization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Authorization(";
  out << "name=" << to_string(name);
  out << ", " << "expirationDate=" << to_string(expirationDate);
  out << ")";
}


Instrument::~Instrument() throw() {
}


void Instrument::__set_uuid(const std::string& val) {
  this->uuid = val;
}

void Instrument::__set_name(const std::string& val) {
  this->name = val;
}

void Instrument::__set_type(const std::string& val) {
  this->type = val;
}

void Instrument::__set_model(const std::string& val) {
  this->model = val;
}

void Instrument::__set_sn(const std::string& val) {
  this->sn = val;
}

void Instrument::__set_version(const std::string& val) {
  this->version = val;
}

void Instrument::__set_targets(const std::vector<std::string> & val) {
  this->targets = val;
}

void Instrument::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
}

void Instrument::__set_authorization(const Authorization& val) {
  this->authorization = val;
}

void Instrument::__set_circuitBoards(const std::vector<CircuitBoard> & val) {
  this->circuitBoards = val;
}

void Instrument::__set_platformVersion(const std::string& val) {
  this->platformVersion = val;
}

void Instrument::__set_unit(const std::string& val) {
  this->unit = val;
__isset.unit = true;
}

void Instrument::__set_proportion(const double val) {
  this->proportion = val;
__isset.proportion = true;
}

void Instrument::__set_waveType(const std::string& val) {
  this->waveType = val;
__isset.waveType = true;
}

uint32_t Instrument::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->uuid);
          this->__isset.uuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sn);
          this->__isset.sn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->targets.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->targets.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += iprot->readString(this->targets[_i6]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.targets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->authorization.read(iprot);
          this->__isset.authorization = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->circuitBoards.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _etype10;
            xfer += iprot->readListBegin(_etype10, _size7);
            this->circuitBoards.resize(_size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              xfer += this->circuitBoards[_i11].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.circuitBoards = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->platformVersion);
          this->__isset.platformVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->proportion);
          this->__isset.proportion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->waveType);
          this->__isset.waveType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Instrument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Instrument");

  xfer += oprot->writeFieldBegin("uuid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->uuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->model);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sn", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->sn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targets", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->targets.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->targets.begin(); _iter12 != this->targets.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->manufacturer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("authorization", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->authorization.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("circuitBoards", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->circuitBoards.size()));
    std::vector<CircuitBoard> ::const_iterator _iter13;
    for (_iter13 = this->circuitBoards.begin(); _iter13 != this->circuitBoards.end(); ++_iter13)
    {
      xfer += (*_iter13).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("platformVersion", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->platformVersion);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.unit) {
    xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 12);
    xfer += oprot->writeString(this->unit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.proportion) {
    xfer += oprot->writeFieldBegin("proportion", ::apache::thrift::protocol::T_DOUBLE, 13);
    xfer += oprot->writeDouble(this->proportion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.waveType) {
    xfer += oprot->writeFieldBegin("waveType", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->waveType);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Instrument &a, Instrument &b) {
  using ::std::swap;
  swap(a.uuid, b.uuid);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.model, b.model);
  swap(a.sn, b.sn);
  swap(a.version, b.version);
  swap(a.targets, b.targets);
  swap(a.manufacturer, b.manufacturer);
  swap(a.authorization, b.authorization);
  swap(a.circuitBoards, b.circuitBoards);
  swap(a.platformVersion, b.platformVersion);
  swap(a.unit, b.unit);
  swap(a.proportion, b.proportion);
  swap(a.waveType, b.waveType);
  swap(a.__isset, b.__isset);
}

Instrument::Instrument(const Instrument& other14) {
  uuid = other14.uuid;
  name = other14.name;
  type = other14.type;
  model = other14.model;
  sn = other14.sn;
  version = other14.version;
  targets = other14.targets;
  manufacturer = other14.manufacturer;
  authorization = other14.authorization;
  circuitBoards = other14.circuitBoards;
  platformVersion = other14.platformVersion;
  unit = other14.unit;
  proportion = other14.proportion;
  waveType = other14.waveType;
  __isset = other14.__isset;
}
Instrument& Instrument::operator=(const Instrument& other15) {
  uuid = other15.uuid;
  name = other15.name;
  type = other15.type;
  model = other15.model;
  sn = other15.sn;
  version = other15.version;
  targets = other15.targets;
  manufacturer = other15.manufacturer;
  authorization = other15.authorization;
  circuitBoards = other15.circuitBoards;
  platformVersion = other15.platformVersion;
  unit = other15.unit;
  proportion = other15.proportion;
  waveType = other15.waveType;
  __isset = other15.__isset;
  return *this;
}
void Instrument::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Instrument(";
  out << "uuid=" << to_string(uuid);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "model=" << to_string(model);
  out << ", " << "sn=" << to_string(sn);
  out << ", " << "version=" << to_string(version);
  out << ", " << "targets=" << to_string(targets);
  out << ", " << "manufacturer=" << to_string(manufacturer);
  out << ", " << "authorization=" << to_string(authorization);
  out << ", " << "circuitBoards=" << to_string(circuitBoards);
  out << ", " << "platformVersion=" << to_string(platformVersion);
  out << ", " << "unit="; (__isset.unit ? (out << to_string(unit)) : (out << "<null>"));
  out << ", " << "proportion="; (__isset.proportion ? (out << to_string(proportion)) : (out << "<null>"));
  out << ", " << "waveType="; (__isset.waveType ? (out << to_string(waveType)) : (out << "<null>"));
  out << ")";
}


CircuitBoard::~CircuitBoard() throw() {
}


void CircuitBoard::__set_name(const std::string& val) {
  this->name = val;
}

void CircuitBoard::__set_type(const std::string& val) {
  this->type = val;
}

void CircuitBoard::__set_model(const std::string& val) {
  this->model = val;
}

void CircuitBoard::__set_sn(const std::string& val) {
  this->sn = val;
}

void CircuitBoard::__set_manufacturer(const std::string& val) {
  this->manufacturer = val;
}

void CircuitBoard::__set_manufDate(const std::string& val) {
  this->manufDate = val;
}

void CircuitBoard::__set_softwareVersion(const std::string& val) {
  this->softwareVersion = val;
}

void CircuitBoard::__set_hardwareVersion(const std::string& val) {
  this->hardwareVersion = val;
}

void CircuitBoard::__set_kernelVersion(const std::string& val) {
  this->kernelVersion = val;
}

void CircuitBoard::__set_fileSystemVersion(const std::string& val) {
  this->fileSystemVersion = val;
}

uint32_t CircuitBoard::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->model);
          this->__isset.model = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sn);
          this->__isset.sn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufacturer);
          this->__isset.manufacturer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->manufDate);
          this->__isset.manufDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->softwareVersion);
          this->__isset.softwareVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->hardwareVersion);
          this->__isset.hardwareVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->kernelVersion);
          this->__isset.kernelVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fileSystemVersion);
          this->__isset.fileSystemVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CircuitBoard::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CircuitBoard");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("model", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->model);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sn", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->sn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manufacturer", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->manufacturer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manufDate", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->manufDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("softwareVersion", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->softwareVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hardwareVersion", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->hardwareVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kernelVersion", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->kernelVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fileSystemVersion", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->fileSystemVersion);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CircuitBoard &a, CircuitBoard &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.model, b.model);
  swap(a.sn, b.sn);
  swap(a.manufacturer, b.manufacturer);
  swap(a.manufDate, b.manufDate);
  swap(a.softwareVersion, b.softwareVersion);
  swap(a.hardwareVersion, b.hardwareVersion);
  swap(a.kernelVersion, b.kernelVersion);
  swap(a.fileSystemVersion, b.fileSystemVersion);
  swap(a.__isset, b.__isset);
}

CircuitBoard::CircuitBoard(const CircuitBoard& other16) {
  name = other16.name;
  type = other16.type;
  model = other16.model;
  sn = other16.sn;
  manufacturer = other16.manufacturer;
  manufDate = other16.manufDate;
  softwareVersion = other16.softwareVersion;
  hardwareVersion = other16.hardwareVersion;
  kernelVersion = other16.kernelVersion;
  fileSystemVersion = other16.fileSystemVersion;
  __isset = other16.__isset;
}
CircuitBoard& CircuitBoard::operator=(const CircuitBoard& other17) {
  name = other17.name;
  type = other17.type;
  model = other17.model;
  sn = other17.sn;
  manufacturer = other17.manufacturer;
  manufDate = other17.manufDate;
  softwareVersion = other17.softwareVersion;
  hardwareVersion = other17.hardwareVersion;
  kernelVersion = other17.kernelVersion;
  fileSystemVersion = other17.fileSystemVersion;
  __isset = other17.__isset;
  return *this;
}
void CircuitBoard::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CircuitBoard(";
  out << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "model=" << to_string(model);
  out << ", " << "sn=" << to_string(sn);
  out << ", " << "manufacturer=" << to_string(manufacturer);
  out << ", " << "manufDate=" << to_string(manufDate);
  out << ", " << "softwareVersion=" << to_string(softwareVersion);
  out << ", " << "hardwareVersion=" << to_string(hardwareVersion);
  out << ", " << "kernelVersion=" << to_string(kernelVersion);
  out << ", " << "fileSystemVersion=" << to_string(fileSystemVersion);
  out << ")";
}


Status::~Status() throw() {
}


void Status::__set_time(const int64_t val) {
  this->time = val;
}

void Status::__set_name(const std::string& val) {
  this->name = val;
}

void Status::__set_text(const std::string& val) {
  this->text = val;
}

void Status::__set_duration(const double val) {
  this->duration = val;
}

uint32_t Status::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->duration);
          this->__isset.duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Status::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Status");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->duration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Status &a, Status &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.duration, b.duration);
  swap(a.__isset, b.__isset);
}

Status::Status(const Status& other18) {
  time = other18.time;
  name = other18.name;
  text = other18.text;
  duration = other18.duration;
  __isset = other18.__isset;
}
Status& Status::operator=(const Status& other19) {
  time = other19.time;
  name = other19.name;
  text = other19.text;
  duration = other19.duration;
  __isset = other19.__isset;
  return *this;
}
void Status::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Status(";
  out << "time=" << to_string(time);
  out << ", " << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "duration=" << to_string(duration);
  out << ")";
}


Alarm::~Alarm() throw() {
}


void Alarm::__set_time(const int64_t val) {
  this->time = val;
}

void Alarm::__set_level(const std::string& val) {
  this->level = val;
}

void Alarm::__set_type(const std::string& val) {
  this->type = val;
}

void Alarm::__set_name(const std::string& val) {
  this->name = val;
}

void Alarm::__set_cause(const std::string& val) {
  this->cause = val;
}

uint32_t Alarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cause);
          this->__isset.cause = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Alarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Alarm");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->level);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cause", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->cause);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Alarm &a, Alarm &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.level, b.level);
  swap(a.type, b.type);
  swap(a.name, b.name);
  swap(a.cause, b.cause);
  swap(a.__isset, b.__isset);
}

Alarm::Alarm(const Alarm& other20) {
  time = other20.time;
  level = other20.level;
  type = other20.type;
  name = other20.name;
  cause = other20.cause;
  __isset = other20.__isset;
}
Alarm& Alarm::operator=(const Alarm& other21) {
  time = other21.time;
  level = other21.level;
  type = other21.type;
  name = other21.name;
  cause = other21.cause;
  __isset = other21.__isset;
  return *this;
}
void Alarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Alarm(";
  out << "time=" << to_string(time);
  out << ", " << "level=" << to_string(level);
  out << ", " << "type=" << to_string(type);
  out << ", " << "name=" << to_string(name);
  out << ", " << "cause=" << to_string(cause);
  out << ")";
}


MeasureData::~MeasureData() throw() {
}


void MeasureData::__set_time(const int64_t val) {
  this->time = val;
}

void MeasureData::__set_result(const double val) {
  this->result = val;
}

void MeasureData::__set_mode(const int32_t val) {
  this->mode = val;
}

void MeasureData::__set_type(const std::string& val) {
  this->type = val;
}

void MeasureData::__set_target(const std::string& val) {
  this->target = val;
}

void MeasureData::__set_optionals(const std::vector<MeasureItem> & val) {
  this->optionals = val;
}

void MeasureData::__set_waveforms(const std::vector<MeasureWaveform> & val) {
  this->waveforms = val;
}

void MeasureData::__set_resultFormat(const std::string& val) {
  this->resultFormat = val;
}

uint32_t MeasureData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->optionals.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->optionals.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += this->optionals[_i26].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.optionals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->waveforms.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->waveforms.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += this->waveforms[_i31].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.waveforms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resultFormat);
          this->__isset.resultFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureData");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optionals", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->optionals.size()));
    std::vector<MeasureItem> ::const_iterator _iter32;
    for (_iter32 = this->optionals.begin(); _iter32 != this->optionals.end(); ++_iter32)
    {
      xfer += (*_iter32).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waveforms", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->waveforms.size()));
    std::vector<MeasureWaveform> ::const_iterator _iter33;
    for (_iter33 = this->waveforms.begin(); _iter33 != this->waveforms.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultFormat", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->resultFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureData &a, MeasureData &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.result, b.result);
  swap(a.mode, b.mode);
  swap(a.type, b.type);
  swap(a.target, b.target);
  swap(a.optionals, b.optionals);
  swap(a.waveforms, b.waveforms);
  swap(a.resultFormat, b.resultFormat);
  swap(a.__isset, b.__isset);
}

MeasureData::MeasureData(const MeasureData& other34) {
  time = other34.time;
  result = other34.result;
  mode = other34.mode;
  type = other34.type;
  target = other34.target;
  optionals = other34.optionals;
  waveforms = other34.waveforms;
  resultFormat = other34.resultFormat;
  __isset = other34.__isset;
}
MeasureData& MeasureData::operator=(const MeasureData& other35) {
  time = other35.time;
  result = other35.result;
  mode = other35.mode;
  type = other35.type;
  target = other35.target;
  optionals = other35.optionals;
  waveforms = other35.waveforms;
  resultFormat = other35.resultFormat;
  __isset = other35.__isset;
  return *this;
}
void MeasureData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureData(";
  out << "time=" << to_string(time);
  out << ", " << "result=" << to_string(result);
  out << ", " << "mode=" << to_string(mode);
  out << ", " << "type=" << to_string(type);
  out << ", " << "target=" << to_string(target);
  out << ", " << "optionals=" << to_string(optionals);
  out << ", " << "waveforms=" << to_string(waveforms);
  out << ", " << "resultFormat=" << to_string(resultFormat);
  out << ")";
}


MeasureItem::~MeasureItem() throw() {
}


void MeasureItem::__set_name(const std::string& val) {
  this->name = val;
}

void MeasureItem::__set_value(const std::string& val) {
  this->value = val;
}

void MeasureItem::__set_unit(const std::string& val) {
  this->unit = val;
}

uint32_t MeasureItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->unit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureItem &a, MeasureItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.unit, b.unit);
  swap(a.__isset, b.__isset);
}

MeasureItem::MeasureItem(const MeasureItem& other36) {
  name = other36.name;
  value = other36.value;
  unit = other36.unit;
  __isset = other36.__isset;
}
MeasureItem& MeasureItem::operator=(const MeasureItem& other37) {
  name = other37.name;
  value = other37.value;
  unit = other37.unit;
  __isset = other37.__isset;
  return *this;
}
void MeasureItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureItem(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ", " << "unit=" << to_string(unit);
  out << ")";
}


MeasureCurve::~MeasureCurve() throw() {
}


void MeasureCurve::__set_time(const int64_t val) {
  this->time = val;
}

void MeasureCurve::__set_k(const double val) {
  this->k = val;
}

void MeasureCurve::__set_b(const double val) {
  this->b = val;
}

void MeasureCurve::__set_curve(const std::string& val) {
  this->curve = val;
}

void MeasureCurve::__set_optionals(const std::vector<MeasureItem> & val) {
  this->optionals = val;
}

void MeasureCurve::__set_waveforms(const std::vector<MeasureWaveform> & val) {
  this->waveforms = val;
}

void MeasureCurve::__set_target(const std::string& val) {
  this->target = val;
}

void MeasureCurve::__set_resultFormat(const std::string& val) {
  this->resultFormat = val;
}

uint32_t MeasureCurve::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->k);
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->b);
          this->__isset.b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->curve);
          this->__isset.curve = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->optionals.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->optionals.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += this->optionals[_i42].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.optionals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->waveforms.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->waveforms.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += this->waveforms[_i47].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.waveforms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resultFormat);
          this->__isset.resultFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureCurve::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureCurve");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->k);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("b", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->b);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("curve", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->curve);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optionals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->optionals.size()));
    std::vector<MeasureItem> ::const_iterator _iter48;
    for (_iter48 = this->optionals.begin(); _iter48 != this->optionals.end(); ++_iter48)
    {
      xfer += (*_iter48).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waveforms", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->waveforms.size()));
    std::vector<MeasureWaveform> ::const_iterator _iter49;
    for (_iter49 = this->waveforms.begin(); _iter49 != this->waveforms.end(); ++_iter49)
    {
      xfer += (*_iter49).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultFormat", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->resultFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureCurve &a, MeasureCurve &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.k, b.k);
  swap(a.b, b.b);
  swap(a.curve, b.curve);
  swap(a.optionals, b.optionals);
  swap(a.waveforms, b.waveforms);
  swap(a.target, b.target);
  swap(a.resultFormat, b.resultFormat);
  swap(a.__isset, b.__isset);
}

MeasureCurve::MeasureCurve(const MeasureCurve& other50) {
  time = other50.time;
  k = other50.k;
  b = other50.b;
  curve = other50.curve;
  optionals = other50.optionals;
  waveforms = other50.waveforms;
  target = other50.target;
  resultFormat = other50.resultFormat;
  __isset = other50.__isset;
}
MeasureCurve& MeasureCurve::operator=(const MeasureCurve& other51) {
  time = other51.time;
  k = other51.k;
  b = other51.b;
  curve = other51.curve;
  optionals = other51.optionals;
  waveforms = other51.waveforms;
  target = other51.target;
  resultFormat = other51.resultFormat;
  __isset = other51.__isset;
  return *this;
}
void MeasureCurve::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureCurve(";
  out << "time=" << to_string(time);
  out << ", " << "k=" << to_string(k);
  out << ", " << "b=" << to_string(b);
  out << ", " << "curve=" << to_string(curve);
  out << ", " << "optionals=" << to_string(optionals);
  out << ", " << "waveforms=" << to_string(waveforms);
  out << ", " << "target=" << to_string(target);
  out << ", " << "resultFormat=" << to_string(resultFormat);
  out << ")";
}


MeasureWaveform::~MeasureWaveform() throw() {
}


void MeasureWaveform::__set_name(const std::string& val) {
  this->name = val;
}

void MeasureWaveform::__set_sampleRate(const double val) {
  this->sampleRate = val;
}

void MeasureWaveform::__set_sampleNum(const int32_t val) {
  this->sampleNum = val;
}

void MeasureWaveform::__set_sampleType(const DataType::type val) {
  this->sampleType = val;
}

void MeasureWaveform::__set_xBegin(const double val) {
  this->xBegin = val;
}

void MeasureWaveform::__set_xInterval(const double val) {
  this->xInterval = val;
}

void MeasureWaveform::__set_xUnit(const std::string& val) {
  this->xUnit = val;
}

void MeasureWaveform::__set_yUnit(const std::string& val) {
  this->yUnit = val;
}

void MeasureWaveform::__set_samples(const std::string& val) {
  this->samples = val;
}

uint32_t MeasureWaveform::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sampleRate);
          this->__isset.sampleRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sampleNum);
          this->__isset.sampleNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->sampleType = (DataType::type)ecast52;
          this->__isset.sampleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xBegin);
          this->__isset.xBegin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xInterval);
          this->__isset.xInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xUnit);
          this->__isset.xUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->yUnit);
          this->__isset.yUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->samples);
          this->__isset.samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureWaveform::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureWaveform");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->sampleRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->sampleNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->sampleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xBegin", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->xBegin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xInterval", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->xInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xUnit", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->xUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("yUnit", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->yUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samples", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeBinary(this->samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureWaveform &a, MeasureWaveform &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.sampleRate, b.sampleRate);
  swap(a.sampleNum, b.sampleNum);
  swap(a.sampleType, b.sampleType);
  swap(a.xBegin, b.xBegin);
  swap(a.xInterval, b.xInterval);
  swap(a.xUnit, b.xUnit);
  swap(a.yUnit, b.yUnit);
  swap(a.samples, b.samples);
  swap(a.__isset, b.__isset);
}

MeasureWaveform::MeasureWaveform(const MeasureWaveform& other53) {
  name = other53.name;
  sampleRate = other53.sampleRate;
  sampleNum = other53.sampleNum;
  sampleType = other53.sampleType;
  xBegin = other53.xBegin;
  xInterval = other53.xInterval;
  xUnit = other53.xUnit;
  yUnit = other53.yUnit;
  samples = other53.samples;
  __isset = other53.__isset;
}
MeasureWaveform& MeasureWaveform::operator=(const MeasureWaveform& other54) {
  name = other54.name;
  sampleRate = other54.sampleRate;
  sampleNum = other54.sampleNum;
  sampleType = other54.sampleType;
  xBegin = other54.xBegin;
  xInterval = other54.xInterval;
  xUnit = other54.xUnit;
  yUnit = other54.yUnit;
  samples = other54.samples;
  __isset = other54.__isset;
  return *this;
}
void MeasureWaveform::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureWaveform(";
  out << "name=" << to_string(name);
  out << ", " << "sampleRate=" << to_string(sampleRate);
  out << ", " << "sampleNum=" << to_string(sampleNum);
  out << ", " << "sampleType=" << to_string(sampleType);
  out << ", " << "xBegin=" << to_string(xBegin);
  out << ", " << "xInterval=" << to_string(xInterval);
  out << ", " << "xUnit=" << to_string(xUnit);
  out << ", " << "yUnit=" << to_string(yUnit);
  out << ", " << "samples=" << to_string(samples);
  out << ")";
}


Profile::~Profile() throw() {
}


void Profile::__set_name(const std::string& val) {
  this->name = val;
}

void Profile::__set_text(const std::string& val) {
  this->text = val;
}

void Profile::__set_groups(const std::vector<ConfigGrop> & val) {
  this->groups = val;
}

void Profile::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void Profile::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

uint32_t Profile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size55;
            ::apache::thrift::protocol::TType _etype58;
            xfer += iprot->readListBegin(_etype58, _size55);
            this->groups.resize(_size55);
            uint32_t _i59;
            for (_i59 = 0; _i59 < _size55; ++_i59)
            {
              xfer += this->groups[_i59].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->writePrivilege = (RoleType::type)ecast60;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->readPrivilege = (RoleType::type)ecast61;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Profile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Profile");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::vector<ConfigGrop> ::const_iterator _iter62;
    for (_iter62 = this->groups.begin(); _iter62 != this->groups.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Profile &a, Profile &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.groups, b.groups);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.__isset, b.__isset);
}

Profile::Profile(const Profile& other63) {
  name = other63.name;
  text = other63.text;
  groups = other63.groups;
  writePrivilege = other63.writePrivilege;
  readPrivilege = other63.readPrivilege;
  __isset = other63.__isset;
}
Profile& Profile::operator=(const Profile& other64) {
  name = other64.name;
  text = other64.text;
  groups = other64.groups;
  writePrivilege = other64.writePrivilege;
  readPrivilege = other64.readPrivilege;
  __isset = other64.__isset;
  return *this;
}
void Profile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Profile(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "groups=" << to_string(groups);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ")";
}


ConfigGrop::~ConfigGrop() throw() {
}


void ConfigGrop::__set_name(const std::string& val) {
  this->name = val;
}

void ConfigGrop::__set_text(const std::string& val) {
  this->text = val;
}

void ConfigGrop::__set_configs(const std::vector<ConfigItem> & val) {
  this->configs = val;
}

uint32_t ConfigGrop::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->configs.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->configs.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->configs[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.configs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigGrop::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigGrop");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("configs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->configs.size()));
    std::vector<ConfigItem> ::const_iterator _iter70;
    for (_iter70 = this->configs.begin(); _iter70 != this->configs.end(); ++_iter70)
    {
      xfer += (*_iter70).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigGrop &a, ConfigGrop &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.configs, b.configs);
  swap(a.__isset, b.__isset);
}

ConfigGrop::ConfigGrop(const ConfigGrop& other71) {
  name = other71.name;
  text = other71.text;
  configs = other71.configs;
  __isset = other71.__isset;
}
ConfigGrop& ConfigGrop::operator=(const ConfigGrop& other72) {
  name = other72.name;
  text = other72.text;
  configs = other72.configs;
  __isset = other72.__isset;
  return *this;
}
void ConfigGrop::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigGrop(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "configs=" << to_string(configs);
  out << ")";
}


ConfigItem::~ConfigItem() throw() {
}


void ConfigItem::__set_name(const std::string& val) {
  this->name = val;
}

void ConfigItem::__set_text(const std::string& val) {
  this->text = val;
}

void ConfigItem::__set_type(const DataType::type val) {
  this->type = val;
}

void ConfigItem::__set_unit(const std::string& val) {
  this->unit = val;
}

void ConfigItem::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void ConfigItem::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

void ConfigItem::__set_options(const std::vector<std::string> & val) {
  this->options = val;
}

void ConfigItem::__set_value(const std::string& val) {
  this->value = val;
}

void ConfigItem::__set_format(const std::string& val) {
  this->format = val;
}

uint32_t ConfigItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->type = (DataType::type)ecast73;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast74;
          xfer += iprot->readI32(ecast74);
          this->writePrivilege = (RoleType::type)ecast74;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast75;
          xfer += iprot->readI32(ecast75);
          this->readPrivilege = (RoleType::type)ecast75;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->options.clear();
            uint32_t _size76;
            ::apache::thrift::protocol::TType _etype79;
            xfer += iprot->readListBegin(_etype79, _size76);
            this->options.resize(_size76);
            uint32_t _i80;
            for (_i80 = 0; _i80 < _size76; ++_i80)
            {
              xfer += iprot->readString(this->options[_i80]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConfigItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConfigItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->unit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::vector<std::string> ::const_iterator _iter81;
    for (_iter81 = this->options.begin(); _iter81 != this->options.end(); ++_iter81)
    {
      xfer += oprot->writeString((*_iter81));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConfigItem &a, ConfigItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.type, b.type);
  swap(a.unit, b.unit);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.options, b.options);
  swap(a.value, b.value);
  swap(a.format, b.format);
  swap(a.__isset, b.__isset);
}

ConfigItem::ConfigItem(const ConfigItem& other82) {
  name = other82.name;
  text = other82.text;
  type = other82.type;
  unit = other82.unit;
  writePrivilege = other82.writePrivilege;
  readPrivilege = other82.readPrivilege;
  options = other82.options;
  value = other82.value;
  format = other82.format;
  __isset = other82.__isset;
}
ConfigItem& ConfigItem::operator=(const ConfigItem& other83) {
  name = other83.name;
  text = other83.text;
  type = other83.type;
  unit = other83.unit;
  writePrivilege = other83.writePrivilege;
  readPrivilege = other83.readPrivilege;
  options = other83.options;
  value = other83.value;
  format = other83.format;
  __isset = other83.__isset;
  return *this;
}
void ConfigItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConfigItem(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "type=" << to_string(type);
  out << ", " << "unit=" << to_string(unit);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ", " << "options=" << to_string(options);
  out << ", " << "value=" << to_string(value);
  out << ", " << "format=" << to_string(format);
  out << ")";
}


Config::~Config() throw() {
}


void Config::__set_profile(const std::string& val) {
  this->profile = val;
}

void Config::__set_config(const std::string& val) {
  this->config = val;
}

void Config::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t Config::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->profile);
          this->__isset.profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Config::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Config");

  xfer += oprot->writeFieldBegin("profile", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->profile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->config);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Config &a, Config &b) {
  using ::std::swap;
  swap(a.profile, b.profile);
  swap(a.config, b.config);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Config::Config(const Config& other84) {
  profile = other84.profile;
  config = other84.config;
  value = other84.value;
  __isset = other84.__isset;
}
Config& Config::operator=(const Config& other85) {
  profile = other85.profile;
  config = other85.config;
  value = other85.value;
  __isset = other85.__isset;
  return *this;
}
void Config::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Config(";
  out << "profile=" << to_string(profile);
  out << ", " << "config=" << to_string(config);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


ConsumableConfigItem::~ConsumableConfigItem() throw() {
}


void ConsumableConfigItem::__set_name(const std::string& val) {
  this->name = val;
}

void ConsumableConfigItem::__set_text(const std::string& val) {
  this->text = val;
}

void ConsumableConfigItem::__set_cycle(const double val) {
  this->cycle = val;
}

void ConsumableConfigItem::__set_lastTime(const int64_t val) {
  this->lastTime = val;
}

uint32_t ConsumableConfigItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cycle);
          this->__isset.cycle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastTime);
          this->__isset.lastTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConsumableConfigItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConsumableConfigItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cycle", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->cycle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->lastTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConsumableConfigItem &a, ConsumableConfigItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.cycle, b.cycle);
  swap(a.lastTime, b.lastTime);
  swap(a.__isset, b.__isset);
}

ConsumableConfigItem::ConsumableConfigItem(const ConsumableConfigItem& other86) {
  name = other86.name;
  text = other86.text;
  cycle = other86.cycle;
  lastTime = other86.lastTime;
  __isset = other86.__isset;
}
ConsumableConfigItem& ConsumableConfigItem::operator=(const ConsumableConfigItem& other87) {
  name = other87.name;
  text = other87.text;
  cycle = other87.cycle;
  lastTime = other87.lastTime;
  __isset = other87.__isset;
  return *this;
}
void ConsumableConfigItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConsumableConfigItem(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "cycle=" << to_string(cycle);
  out << ", " << "lastTime=" << to_string(lastTime);
  out << ")";
}


ReagentConfigItem::~ReagentConfigItem() throw() {
}


void ReagentConfigItem::__set_totalVolume(const double val) {
  this->totalVolume = val;
}

void ReagentConfigItem::__set_remainVolume(const double val) {
  this->remainVolume = val;
}

void ReagentConfigItem::__set_name(const std::string& val) {
  this->name = val;
}

void ReagentConfigItem::__set_text(const std::string& val) {
  this->text = val;
}

void ReagentConfigItem::__set_cycle(const double val) {
  this->cycle = val;
}

void ReagentConfigItem::__set_lastTime(const int64_t val) {
  this->lastTime = val;
}

uint32_t ReagentConfigItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->totalVolume);
          this->__isset.totalVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->remainVolume);
          this->__isset.remainVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->cycle);
          this->__isset.cycle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastTime);
          this->__isset.lastTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReagentConfigItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReagentConfigItem");

  xfer += oprot->writeFieldBegin("totalVolume", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->totalVolume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remainVolume", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->remainVolume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cycle", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->cycle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->lastTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReagentConfigItem &a, ReagentConfigItem &b) {
  using ::std::swap;
  swap(a.totalVolume, b.totalVolume);
  swap(a.remainVolume, b.remainVolume);
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.cycle, b.cycle);
  swap(a.lastTime, b.lastTime);
  swap(a.__isset, b.__isset);
}

ReagentConfigItem::ReagentConfigItem(const ReagentConfigItem& other88) {
  totalVolume = other88.totalVolume;
  remainVolume = other88.remainVolume;
  name = other88.name;
  text = other88.text;
  cycle = other88.cycle;
  lastTime = other88.lastTime;
  __isset = other88.__isset;
}
ReagentConfigItem& ReagentConfigItem::operator=(const ReagentConfigItem& other89) {
  totalVolume = other89.totalVolume;
  remainVolume = other89.remainVolume;
  name = other89.name;
  text = other89.text;
  cycle = other89.cycle;
  lastTime = other89.lastTime;
  __isset = other89.__isset;
  return *this;
}
void ReagentConfigItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReagentConfigItem(";
  out << "totalVolume=" << to_string(totalVolume);
  out << ", " << "remainVolume=" << to_string(remainVolume);
  out << ", " << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "cycle=" << to_string(cycle);
  out << ", " << "lastTime=" << to_string(lastTime);
  out << ")";
}


ReagentRemain::~ReagentRemain() throw() {
}


void ReagentRemain::__set_name(const std::string& val) {
  this->name = val;
}

void ReagentRemain::__set_volume(const double val) {
  this->volume = val;
}

uint32_t ReagentRemain::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->volume);
          this->__isset.volume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReagentRemain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReagentRemain");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("volume", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->volume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReagentRemain &a, ReagentRemain &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.volume, b.volume);
  swap(a.__isset, b.__isset);
}

ReagentRemain::ReagentRemain(const ReagentRemain& other90) {
  name = other90.name;
  volume = other90.volume;
  __isset = other90.__isset;
}
ReagentRemain& ReagentRemain::operator=(const ReagentRemain& other91) {
  name = other91.name;
  volume = other91.volume;
  __isset = other91.__isset;
  return *this;
}
void ReagentRemain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReagentRemain(";
  out << "name=" << to_string(name);
  out << ", " << "volume=" << to_string(volume);
  out << ")";
}


Signal::~Signal() throw() {
}


void Signal::__set_name(const std::string& val) {
  this->name = val;
}

void Signal::__set_value(const double val) {
  this->value = val;
}

uint32_t Signal::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Signal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Signal");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Signal &a, Signal &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Signal::Signal(const Signal& other92) {
  name = other92.name;
  value = other92.value;
  __isset = other92.__isset;
}
Signal& Signal::operator=(const Signal& other93) {
  name = other93.name;
  value = other93.value;
  __isset = other93.__isset;
  return *this;
}
void Signal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Signal(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


OperationSuit::~OperationSuit() throw() {
}


void OperationSuit::__set_name(const std::string& val) {
  this->name = val;
}

void OperationSuit::__set_text(const std::string& val) {
  this->text = val;
}

void OperationSuit::__set_groups(const std::vector<OperationGroup> & val) {
  this->groups = val;
}

void OperationSuit::__set_params(const std::vector<OperationParam> & val) {
  this->params = val;
}

void OperationSuit::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void OperationSuit::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

uint32_t OperationSuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _etype97;
            xfer += iprot->readListBegin(_etype97, _size94);
            this->groups.resize(_size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              xfer += this->groups[_i98].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size99;
            ::apache::thrift::protocol::TType _etype102;
            xfer += iprot->readListBegin(_etype102, _size99);
            this->params.resize(_size99);
            uint32_t _i103;
            for (_i103 = 0; _i103 < _size99; ++_i103)
            {
              xfer += this->params[_i103].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->writePrivilege = (RoleType::type)ecast104;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->readPrivilege = (RoleType::type)ecast105;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationSuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationSuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::vector<OperationGroup> ::const_iterator _iter106;
    for (_iter106 = this->groups.begin(); _iter106 != this->groups.end(); ++_iter106)
    {
      xfer += (*_iter106).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->params.size()));
    std::vector<OperationParam> ::const_iterator _iter107;
    for (_iter107 = this->params.begin(); _iter107 != this->params.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationSuit &a, OperationSuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.groups, b.groups);
  swap(a.params, b.params);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.__isset, b.__isset);
}

OperationSuit::OperationSuit(const OperationSuit& other108) {
  name = other108.name;
  text = other108.text;
  groups = other108.groups;
  params = other108.params;
  writePrivilege = other108.writePrivilege;
  readPrivilege = other108.readPrivilege;
  __isset = other108.__isset;
}
OperationSuit& OperationSuit::operator=(const OperationSuit& other109) {
  name = other109.name;
  text = other109.text;
  groups = other109.groups;
  params = other109.params;
  writePrivilege = other109.writePrivilege;
  readPrivilege = other109.readPrivilege;
  __isset = other109.__isset;
  return *this;
}
void OperationSuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationSuit(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "groups=" << to_string(groups);
  out << ", " << "params=" << to_string(params);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ")";
}


OperationGroup::~OperationGroup() throw() {
}


void OperationGroup::__set_name(const std::string& val) {
  this->name = val;
}

void OperationGroup::__set_text(const std::string& val) {
  this->text = val;
}

void OperationGroup::__set_operations(const std::vector<OperationItem> & val) {
  this->operations = val;
}

uint32_t OperationGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->operations.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->operations.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += this->operations[_i114].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.operations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationGroup");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("operations", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->operations.size()));
    std::vector<OperationItem> ::const_iterator _iter115;
    for (_iter115 = this->operations.begin(); _iter115 != this->operations.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationGroup &a, OperationGroup &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.operations, b.operations);
  swap(a.__isset, b.__isset);
}

OperationGroup::OperationGroup(const OperationGroup& other116) {
  name = other116.name;
  text = other116.text;
  operations = other116.operations;
  __isset = other116.__isset;
}
OperationGroup& OperationGroup::operator=(const OperationGroup& other117) {
  name = other117.name;
  text = other117.text;
  operations = other117.operations;
  __isset = other117.__isset;
  return *this;
}
void OperationGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationGroup(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "operations=" << to_string(operations);
  out << ")";
}


OperationItem::~OperationItem() throw() {
}


void OperationItem::__set_name(const std::string& val) {
  this->name = val;
}

void OperationItem::__set_text(const std::string& val) {
  this->text = val;
}

void OperationItem::__set_params(const std::vector<std::string> & val) {
  this->params = val;
}

void OperationItem::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void OperationItem::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

uint32_t OperationItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->params.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readString(this->params[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->writePrivilege = (RoleType::type)ecast123;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast124;
          xfer += iprot->readI32(ecast124);
          this->readPrivilege = (RoleType::type)ecast124;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::vector<std::string> ::const_iterator _iter125;
    for (_iter125 = this->params.begin(); _iter125 != this->params.end(); ++_iter125)
    {
      xfer += oprot->writeString((*_iter125));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationItem &a, OperationItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.params, b.params);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.__isset, b.__isset);
}

OperationItem::OperationItem(const OperationItem& other126) {
  name = other126.name;
  text = other126.text;
  params = other126.params;
  writePrivilege = other126.writePrivilege;
  readPrivilege = other126.readPrivilege;
  __isset = other126.__isset;
}
OperationItem& OperationItem::operator=(const OperationItem& other127) {
  name = other127.name;
  text = other127.text;
  params = other127.params;
  writePrivilege = other127.writePrivilege;
  readPrivilege = other127.readPrivilege;
  __isset = other127.__isset;
  return *this;
}
void OperationItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationItem(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "params=" << to_string(params);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ")";
}


OperationParam::~OperationParam() throw() {
}


void OperationParam::__set_name(const std::string& val) {
  this->name = val;
}

void OperationParam::__set_text(const std::string& val) {
  this->text = val;
}

void OperationParam::__set_type(const DataType::type val) {
  this->type = val;
}

void OperationParam::__set_unit(const std::string& val) {
  this->unit = val;
}

void OperationParam::__set_options(const std::vector<std::string> & val) {
  this->options = val;
}

uint32_t OperationParam::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast128;
          xfer += iprot->readI32(ecast128);
          this->type = (DataType::type)ecast128;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->options.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->options.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              xfer += iprot->readString(this->options[_i133]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OperationParam::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OperationParam");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->unit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->options.size()));
    std::vector<std::string> ::const_iterator _iter134;
    for (_iter134 = this->options.begin(); _iter134 != this->options.end(); ++_iter134)
    {
      xfer += oprot->writeString((*_iter134));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OperationParam &a, OperationParam &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.type, b.type);
  swap(a.unit, b.unit);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

OperationParam::OperationParam(const OperationParam& other135) {
  name = other135.name;
  text = other135.text;
  type = other135.type;
  unit = other135.unit;
  options = other135.options;
  __isset = other135.__isset;
}
OperationParam& OperationParam::operator=(const OperationParam& other136) {
  name = other136.name;
  text = other136.text;
  type = other136.type;
  unit = other136.unit;
  options = other136.options;
  __isset = other136.__isset;
  return *this;
}
void OperationParam::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OperationParam(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "type=" << to_string(type);
  out << ", " << "unit=" << to_string(unit);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


DiagnosisSuit::~DiagnosisSuit() throw() {
}


void DiagnosisSuit::__set_name(const std::string& val) {
  this->name = val;
}

void DiagnosisSuit::__set_text(const std::string& val) {
  this->text = val;
}

void DiagnosisSuit::__set_groups(const std::vector<DiagnosisGroup> & val) {
  this->groups = val;
}

void DiagnosisSuit::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void DiagnosisSuit::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

uint32_t DiagnosisSuit::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->groups.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->groups.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += this->groups[_i141].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.groups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast142;
          xfer += iprot->readI32(ecast142);
          this->writePrivilege = (RoleType::type)ecast142;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast143;
          xfer += iprot->readI32(ecast143);
          this->readPrivilege = (RoleType::type)ecast143;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiagnosisSuit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiagnosisSuit");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("groups", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->groups.size()));
    std::vector<DiagnosisGroup> ::const_iterator _iter144;
    for (_iter144 = this->groups.begin(); _iter144 != this->groups.end(); ++_iter144)
    {
      xfer += (*_iter144).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiagnosisSuit &a, DiagnosisSuit &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.groups, b.groups);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.__isset, b.__isset);
}

DiagnosisSuit::DiagnosisSuit(const DiagnosisSuit& other145) {
  name = other145.name;
  text = other145.text;
  groups = other145.groups;
  writePrivilege = other145.writePrivilege;
  readPrivilege = other145.readPrivilege;
  __isset = other145.__isset;
}
DiagnosisSuit& DiagnosisSuit::operator=(const DiagnosisSuit& other146) {
  name = other146.name;
  text = other146.text;
  groups = other146.groups;
  writePrivilege = other146.writePrivilege;
  readPrivilege = other146.readPrivilege;
  __isset = other146.__isset;
  return *this;
}
void DiagnosisSuit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiagnosisSuit(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "groups=" << to_string(groups);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ")";
}


DiagnosisGroup::~DiagnosisGroup() throw() {
}


void DiagnosisGroup::__set_name(const std::string& val) {
  this->name = val;
}

void DiagnosisGroup::__set_text(const std::string& val) {
  this->text = val;
}

void DiagnosisGroup::__set_diagnoses(const std::vector<DiagnosisItem> & val) {
  this->diagnoses = val;
}

uint32_t DiagnosisGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->diagnoses.clear();
            uint32_t _size147;
            ::apache::thrift::protocol::TType _etype150;
            xfer += iprot->readListBegin(_etype150, _size147);
            this->diagnoses.resize(_size147);
            uint32_t _i151;
            for (_i151 = 0; _i151 < _size147; ++_i151)
            {
              xfer += this->diagnoses[_i151].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.diagnoses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiagnosisGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiagnosisGroup");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("diagnoses", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->diagnoses.size()));
    std::vector<DiagnosisItem> ::const_iterator _iter152;
    for (_iter152 = this->diagnoses.begin(); _iter152 != this->diagnoses.end(); ++_iter152)
    {
      xfer += (*_iter152).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiagnosisGroup &a, DiagnosisGroup &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.diagnoses, b.diagnoses);
  swap(a.__isset, b.__isset);
}

DiagnosisGroup::DiagnosisGroup(const DiagnosisGroup& other153) {
  name = other153.name;
  text = other153.text;
  diagnoses = other153.diagnoses;
  __isset = other153.__isset;
}
DiagnosisGroup& DiagnosisGroup::operator=(const DiagnosisGroup& other154) {
  name = other154.name;
  text = other154.text;
  diagnoses = other154.diagnoses;
  __isset = other154.__isset;
  return *this;
}
void DiagnosisGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiagnosisGroup(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "diagnoses=" << to_string(diagnoses);
  out << ")";
}


DiagnosisItem::~DiagnosisItem() throw() {
}


void DiagnosisItem::__set_name(const std::string& val) {
  this->name = val;
}

void DiagnosisItem::__set_text(const std::string& val) {
  this->text = val;
}

void DiagnosisItem::__set_writePrivilege(const RoleType::type val) {
  this->writePrivilege = val;
}

void DiagnosisItem::__set_readPrivilege(const RoleType::type val) {
  this->readPrivilege = val;
}

uint32_t DiagnosisItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->text);
          this->__isset.text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast155;
          xfer += iprot->readI32(ecast155);
          this->writePrivilege = (RoleType::type)ecast155;
          this->__isset.writePrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast156;
          xfer += iprot->readI32(ecast156);
          this->readPrivilege = (RoleType::type)ecast156;
          this->__isset.readPrivilege = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiagnosisItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiagnosisItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writePrivilege", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->writePrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("readPrivilege", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->readPrivilege);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiagnosisItem &a, DiagnosisItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.text, b.text);
  swap(a.writePrivilege, b.writePrivilege);
  swap(a.readPrivilege, b.readPrivilege);
  swap(a.__isset, b.__isset);
}

DiagnosisItem::DiagnosisItem(const DiagnosisItem& other157) {
  name = other157.name;
  text = other157.text;
  writePrivilege = other157.writePrivilege;
  readPrivilege = other157.readPrivilege;
  __isset = other157.__isset;
}
DiagnosisItem& DiagnosisItem::operator=(const DiagnosisItem& other158) {
  name = other158.name;
  text = other158.text;
  writePrivilege = other158.writePrivilege;
  readPrivilege = other158.readPrivilege;
  __isset = other158.__isset;
  return *this;
}
void DiagnosisItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiagnosisItem(";
  out << "name=" << to_string(name);
  out << ", " << "text=" << to_string(text);
  out << ", " << "writePrivilege=" << to_string(writePrivilege);
  out << ", " << "readPrivilege=" << to_string(readPrivilege);
  out << ")";
}


DiagnosisResult::~DiagnosisResult() throw() {
}


void DiagnosisResult::__set_suit(const std::string& val) {
  this->suit = val;
}

void DiagnosisResult::__set_name(const std::string& val) {
  this->name = val;
}

void DiagnosisResult::__set_result(const std::string& val) {
  this->result = val;
}

uint32_t DiagnosisResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->suit);
          this->__isset.suit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DiagnosisResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DiagnosisResult");

  xfer += oprot->writeFieldBegin("suit", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->suit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DiagnosisResult &a, DiagnosisResult &b) {
  using ::std::swap;
  swap(a.suit, b.suit);
  swap(a.name, b.name);
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

DiagnosisResult::DiagnosisResult(const DiagnosisResult& other159) {
  suit = other159.suit;
  name = other159.name;
  result = other159.result;
  __isset = other159.__isset;
}
DiagnosisResult& DiagnosisResult::operator=(const DiagnosisResult& other160) {
  suit = other160.suit;
  name = other160.name;
  result = other160.result;
  __isset = other160.__isset;
  return *this;
}
void DiagnosisResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DiagnosisResult(";
  out << "suit=" << to_string(suit);
  out << ", " << "name=" << to_string(name);
  out << ", " << "result=" << to_string(result);
  out << ")";
}

}}}} // namespace
