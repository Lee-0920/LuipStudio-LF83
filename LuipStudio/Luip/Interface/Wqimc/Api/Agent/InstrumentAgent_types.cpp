/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "InstrumentAgent_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Interface { namespace Wqimc { namespace Api { namespace Agent {

int _kMeasureModeValues[] = {
  MeasureMode::Online,
  MeasureMode::Offine
};
const char* _kMeasureModeNames[] = {
  "Online",
  "Offine"
};
const std::map<int, const char*> _MeasureMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMeasureModeValues, _kMeasureModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDataTypeValues[] = {
  DataType::Bool,
  DataType::Option,
  DataType::Int,
  DataType::Float,
  DataType::String,
  DataType::IntArray,
  DataType::Byte,
  DataType::Short,
  DataType::Long,
  DataType::Double
};
const char* _kDataTypeNames[] = {
  "Bool",
  "Option",
  "Int",
  "Float",
  "String",
  "IntArray",
  "Byte",
  "Short",
  "Long",
  "Double"
};
const std::map<int, const char*> _DataType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kDataTypeValues, _kDataTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRoleTypeValues[] = {
  RoleType::Guest,
  RoleType::Administrator,
  RoleType::Engineer,
  RoleType::Super
};
const char* _kRoleTypeNames[] = {
  "Guest",
  "Administrator",
  "Engineer",
  "Super"
};
const std::map<int, const char*> _RoleType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kRoleTypeValues, _kRoleTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Signal::~Signal() throw() {
}


void Signal::__set_name(const std::string& val) {
  this->name = val;
}

void Signal::__set_value(const double val) {
  this->value = val;
}

void Signal::__set_format(const std::string& val) {
  this->format = val;
}

uint32_t Signal::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          this->__isset.format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Signal::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Signal");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Signal &a, Signal &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.format, b.format);
  swap(a.__isset, b.__isset);
}

Signal::Signal(const Signal& other0) {
  name = other0.name;
  value = other0.value;
  format = other0.format;
  __isset = other0.__isset;
}
Signal& Signal::operator=(const Signal& other1) {
  name = other1.name;
  value = other1.value;
  format = other1.format;
  __isset = other1.__isset;
  return *this;
}
void Signal::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Signal(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ", " << "format=" << to_string(format);
  out << ")";
}


Config::~Config() throw() {
}


void Config::__set_profile(const std::string& val) {
  this->profile = val;
}

void Config::__set_config(const std::string& val) {
  this->config = val;
}

void Config::__set_value(const std::string& val) {
  this->value = val;
}

uint32_t Config::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->profile);
          this->__isset.profile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->config);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Config::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Config");

  xfer += oprot->writeFieldBegin("profile", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->profile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->config);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Config &a, Config &b) {
  using ::std::swap;
  swap(a.profile, b.profile);
  swap(a.config, b.config);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Config::Config(const Config& other2) {
  profile = other2.profile;
  config = other2.config;
  value = other2.value;
  __isset = other2.__isset;
}
Config& Config::operator=(const Config& other3) {
  profile = other3.profile;
  config = other3.config;
  value = other3.value;
  __isset = other3.__isset;
  return *this;
}
void Config::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Config(";
  out << "profile=" << to_string(profile);
  out << ", " << "config=" << to_string(config);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


Operation::~Operation() throw() {
}


void Operation::__set_suit(const std::string& val) {
  this->suit = val;
}

void Operation::__set_name(const std::string& val) {
  this->name = val;
}

void Operation::__set_params(const std::vector<std::string> & val) {
  this->params = val;
}

uint32_t Operation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->suit);
          this->__isset.suit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->params.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->params.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readString(this->params[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Operation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Operation");

  xfer += oprot->writeFieldBegin("suit", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->suit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->params.size()));
    std::vector<std::string> ::const_iterator _iter9;
    for (_iter9 = this->params.begin(); _iter9 != this->params.end(); ++_iter9)
    {
      xfer += oprot->writeString((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Operation &a, Operation &b) {
  using ::std::swap;
  swap(a.suit, b.suit);
  swap(a.name, b.name);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

Operation::Operation(const Operation& other10) {
  suit = other10.suit;
  name = other10.name;
  params = other10.params;
  __isset = other10.__isset;
}
Operation& Operation::operator=(const Operation& other11) {
  suit = other11.suit;
  name = other11.name;
  params = other11.params;
  __isset = other11.__isset;
  return *this;
}
void Operation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Operation(";
  out << "suit=" << to_string(suit);
  out << ", " << "name=" << to_string(name);
  out << ", " << "params=" << to_string(params);
  out << ")";
}


MeasureData::~MeasureData() throw() {
}


void MeasureData::__set_time(const int64_t val) {
  this->time = val;
}

void MeasureData::__set_result(const double val) {
  this->result = val;
}

void MeasureData::__set_mode(const int32_t val) {
  this->mode = val;
}

void MeasureData::__set_type(const std::string& val) {
  this->type = val;
}

void MeasureData::__set_target(const std::string& val) {
  this->target = val;
}

void MeasureData::__set_optionals(const std::vector<MeasureItem> & val) {
  this->optionals = val;
}

void MeasureData::__set_waveforms(const std::vector<MeasureWaveform> & val) {
  this->waveforms = val;
}

void MeasureData::__set_resultFormat(const std::string& val) {
  this->resultFormat = val;
}

uint32_t MeasureData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->optionals.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->optionals.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->optionals[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.optionals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->waveforms.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->waveforms.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              xfer += this->waveforms[_i21].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.waveforms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resultFormat);
          this->__isset.resultFormat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureData");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optionals", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->optionals.size()));
    std::vector<MeasureItem> ::const_iterator _iter22;
    for (_iter22 = this->optionals.begin(); _iter22 != this->optionals.end(); ++_iter22)
    {
      xfer += (*_iter22).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("waveforms", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->waveforms.size()));
    std::vector<MeasureWaveform> ::const_iterator _iter23;
    for (_iter23 = this->waveforms.begin(); _iter23 != this->waveforms.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resultFormat", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->resultFormat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureData &a, MeasureData &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.result, b.result);
  swap(a.mode, b.mode);
  swap(a.type, b.type);
  swap(a.target, b.target);
  swap(a.optionals, b.optionals);
  swap(a.waveforms, b.waveforms);
  swap(a.resultFormat, b.resultFormat);
  swap(a.__isset, b.__isset);
}

MeasureData::MeasureData(const MeasureData& other24) {
  time = other24.time;
  result = other24.result;
  mode = other24.mode;
  type = other24.type;
  target = other24.target;
  optionals = other24.optionals;
  waveforms = other24.waveforms;
  resultFormat = other24.resultFormat;
  __isset = other24.__isset;
}
MeasureData& MeasureData::operator=(const MeasureData& other25) {
  time = other25.time;
  result = other25.result;
  mode = other25.mode;
  type = other25.type;
  target = other25.target;
  optionals = other25.optionals;
  waveforms = other25.waveforms;
  resultFormat = other25.resultFormat;
  __isset = other25.__isset;
  return *this;
}
void MeasureData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureData(";
  out << "time=" << to_string(time);
  out << ", " << "result=" << to_string(result);
  out << ", " << "mode=" << to_string(mode);
  out << ", " << "type=" << to_string(type);
  out << ", " << "target=" << to_string(target);
  out << ", " << "optionals=" << to_string(optionals);
  out << ", " << "waveforms=" << to_string(waveforms);
  out << ", " << "resultFormat=" << to_string(resultFormat);
  out << ")";
}


MeasureItem::~MeasureItem() throw() {
}


void MeasureItem::__set_name(const std::string& val) {
  this->name = val;
}

void MeasureItem::__set_value(const std::string& val) {
  this->value = val;
}

void MeasureItem::__set_unit(const std::string& val) {
  this->unit = val;
}

uint32_t MeasureItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->unit);
          this->__isset.unit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureItem");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("unit", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->unit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureItem &a, MeasureItem &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.value, b.value);
  swap(a.unit, b.unit);
  swap(a.__isset, b.__isset);
}

MeasureItem::MeasureItem(const MeasureItem& other26) {
  name = other26.name;
  value = other26.value;
  unit = other26.unit;
  __isset = other26.__isset;
}
MeasureItem& MeasureItem::operator=(const MeasureItem& other27) {
  name = other27.name;
  value = other27.value;
  unit = other27.unit;
  __isset = other27.__isset;
  return *this;
}
void MeasureItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureItem(";
  out << "name=" << to_string(name);
  out << ", " << "value=" << to_string(value);
  out << ", " << "unit=" << to_string(unit);
  out << ")";
}


MeasureWaveform::~MeasureWaveform() throw() {
}


void MeasureWaveform::__set_name(const std::string& val) {
  this->name = val;
}

void MeasureWaveform::__set_sampleRate(const double val) {
  this->sampleRate = val;
}

void MeasureWaveform::__set_sampleNum(const int32_t val) {
  this->sampleNum = val;
}

void MeasureWaveform::__set_sampleType(const DataType::type val) {
  this->sampleType = val;
}

void MeasureWaveform::__set_xBegin(const double val) {
  this->xBegin = val;
}

void MeasureWaveform::__set_xInterval(const double val) {
  this->xInterval = val;
}

void MeasureWaveform::__set_xUnit(const std::string& val) {
  this->xUnit = val;
}

void MeasureWaveform::__set_yUnit(const std::string& val) {
  this->yUnit = val;
}

void MeasureWaveform::__set_samples(const std::string& val) {
  this->samples = val;
}

uint32_t MeasureWaveform::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->sampleRate);
          this->__isset.sampleRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sampleNum);
          this->__isset.sampleNum = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast28;
          xfer += iprot->readI32(ecast28);
          this->sampleType = (DataType::type)ecast28;
          this->__isset.sampleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xBegin);
          this->__isset.xBegin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xInterval);
          this->__isset.xInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xUnit);
          this->__isset.xUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->yUnit);
          this->__isset.yUnit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->samples);
          this->__isset.samples = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MeasureWaveform::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MeasureWaveform");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleRate", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->sampleRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleNum", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->sampleNum);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sampleType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->sampleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xBegin", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->xBegin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xInterval", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->xInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xUnit", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->xUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("yUnit", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->yUnit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("samples", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeBinary(this->samples);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MeasureWaveform &a, MeasureWaveform &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.sampleRate, b.sampleRate);
  swap(a.sampleNum, b.sampleNum);
  swap(a.sampleType, b.sampleType);
  swap(a.xBegin, b.xBegin);
  swap(a.xInterval, b.xInterval);
  swap(a.xUnit, b.xUnit);
  swap(a.yUnit, b.yUnit);
  swap(a.samples, b.samples);
  swap(a.__isset, b.__isset);
}

MeasureWaveform::MeasureWaveform(const MeasureWaveform& other29) {
  name = other29.name;
  sampleRate = other29.sampleRate;
  sampleNum = other29.sampleNum;
  sampleType = other29.sampleType;
  xBegin = other29.xBegin;
  xInterval = other29.xInterval;
  xUnit = other29.xUnit;
  yUnit = other29.yUnit;
  samples = other29.samples;
  __isset = other29.__isset;
}
MeasureWaveform& MeasureWaveform::operator=(const MeasureWaveform& other30) {
  name = other30.name;
  sampleRate = other30.sampleRate;
  sampleNum = other30.sampleNum;
  sampleType = other30.sampleType;
  xBegin = other30.xBegin;
  xInterval = other30.xInterval;
  xUnit = other30.xUnit;
  yUnit = other30.yUnit;
  samples = other30.samples;
  __isset = other30.__isset;
  return *this;
}
void MeasureWaveform::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MeasureWaveform(";
  out << "name=" << to_string(name);
  out << ", " << "sampleRate=" << to_string(sampleRate);
  out << ", " << "sampleNum=" << to_string(sampleNum);
  out << ", " << "sampleType=" << to_string(sampleType);
  out << ", " << "xBegin=" << to_string(xBegin);
  out << ", " << "xInterval=" << to_string(xInterval);
  out << ", " << "xUnit=" << to_string(xUnit);
  out << ", " << "yUnit=" << to_string(yUnit);
  out << ", " << "samples=" << to_string(samples);
  out << ")";
}


Diagnosis::~Diagnosis() throw() {
}


void Diagnosis::__set_suit(const std::string& val) {
  this->suit = val;
}

void Diagnosis::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t Diagnosis::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->suit);
          this->__isset.suit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Diagnosis::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Diagnosis");

  xfer += oprot->writeFieldBegin("suit", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->suit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Diagnosis &a, Diagnosis &b) {
  using ::std::swap;
  swap(a.suit, b.suit);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

Diagnosis::Diagnosis(const Diagnosis& other31) {
  suit = other31.suit;
  name = other31.name;
  __isset = other31.__isset;
}
Diagnosis& Diagnosis::operator=(const Diagnosis& other32) {
  suit = other32.suit;
  name = other32.name;
  __isset = other32.__isset;
  return *this;
}
void Diagnosis::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Diagnosis(";
  out << "suit=" << to_string(suit);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


Authorization::~Authorization() throw() {
}


void Authorization::__set_name(const std::string& val) {
  this->name = val;
}

void Authorization::__set_expirationDate(const int64_t val) {
  this->expirationDate = val;
}

uint32_t Authorization::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expirationDate);
          this->__isset.expirationDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Authorization::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Authorization");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expirationDate", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->expirationDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Authorization &a, Authorization &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.expirationDate, b.expirationDate);
  swap(a.__isset, b.__isset);
}

Authorization::Authorization(const Authorization& other33) {
  name = other33.name;
  expirationDate = other33.expirationDate;
  __isset = other33.__isset;
}
Authorization& Authorization::operator=(const Authorization& other34) {
  name = other34.name;
  expirationDate = other34.expirationDate;
  __isset = other34.__isset;
  return *this;
}
void Authorization::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Authorization(";
  out << "name=" << to_string(name);
  out << ", " << "expirationDate=" << to_string(expirationDate);
  out << ")";
}


InstrumentFile::~InstrumentFile() throw() {
}


void InstrumentFile::__set_name(const std::string& val) {
  this->name = val;
}

void InstrumentFile::__set_isFile(const bool val) {
  this->isFile = val;
}

void InstrumentFile::__set_updateDate(const int64_t val) {
  this->updateDate = val;
}

void InstrumentFile::__set_type(const std::string& val) {
  this->type = val;
}

void InstrumentFile::__set_size(const int64_t val) {
  this->size = val;
}

uint32_t InstrumentFile::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFile);
          this->__isset.isFile = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->updateDate);
          this->__isset.updateDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InstrumentFile::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InstrumentFile");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFile", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->isFile);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updateDate", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->updateDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InstrumentFile &a, InstrumentFile &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.isFile, b.isFile);
  swap(a.updateDate, b.updateDate);
  swap(a.type, b.type);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

InstrumentFile::InstrumentFile(const InstrumentFile& other35) {
  name = other35.name;
  isFile = other35.isFile;
  updateDate = other35.updateDate;
  type = other35.type;
  size = other35.size;
  __isset = other35.__isset;
}
InstrumentFile& InstrumentFile::operator=(const InstrumentFile& other36) {
  name = other36.name;
  isFile = other36.isFile;
  updateDate = other36.updateDate;
  type = other36.type;
  size = other36.size;
  __isset = other36.__isset;
  return *this;
}
void InstrumentFile::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InstrumentFile(";
  out << "name=" << to_string(name);
  out << ", " << "isFile=" << to_string(isFile);
  out << ", " << "updateDate=" << to_string(updateDate);
  out << ", " << "type=" << to_string(type);
  out << ", " << "size=" << to_string(size);
  out << ")";
}

}}}} // namespace
